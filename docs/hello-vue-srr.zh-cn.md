# Hello! Vue SSR!

关于 Vue SSR 的简单介绍，参考官方提供的 [Introduction](https://ssr.vuejs.org/zh/)，里面提到了

- 什么是 SSR
- 为什么使用 SSR
- SSR vs Prerendering

在我们继续往下之前，需要先思考一个问题，**项目里是否真的需要 Vue SSR?** 

回答这个问题，需要结合具体的项目来进行分析。我们先从 Web 近年来架构上的困境和变迁来一步步回顾一下，SSR 的需求是从哪里冒出来的？（这里只探究纯前端的困境。）



## 基于后端模板引擎的传统 Web 项目 

### 困境

- 模板的渲染在服务器端一次性进行，渲染完成后无法在浏览器端**响应式的**根据数据变化**重新渲染**模板
  - 服务器端的 layout 与 widget 只是一种伪组件
  - 碎片化的拼接，新手写的代码通常很难优雅
- 浏览器端基于 RequireJS 的模块代码，难以在 Node 端复用

### 优势

- 异常灵活，几乎没有什么束缚



## SPA

### 困境

- 几乎没有任何服务器端能力
  - 很难优雅地解决一些在浏览器端无法改变，只能在浏览器端根据路由动态决定的内容（title，meta等）
- 使用 history 模式时，需要在服务器端 fallback 到对应的 index.html
  - 难以自由的规模化
- SEO 不友好

### 优势

- 良好的组件化体系



## SSR 用于解决什么问题？

### 优势

- 几乎可以随意拓展的服务器端能力（SPA
- 浏览器端与服务器端路由同构（SPA
- SEO （SPA
- 服务器端模板在浏览器端复用和二次更新（传统
- 浏览器端与服务器端代码复用（传统

### 劣势

- 服务端渲染时的性能开销
- 开发的时候，需要考虑两端通用，对开发人员要求更高



## 项目里是否需要 SSR？

如题，让我们回到刚才那个问题。项目里什么时候需要 SSR？

- 项目是否足够复杂？
- 页面交互是否很复杂？
- SPA + Prerender 是否不能解决问题？
- 是否需要服务端能力？

如果针对上述问题，回答都是肯定的话，那么欢迎来到 SSR 的世界，一种通过架构上的设计来彻底解放服务器端想象力的方案。通过 SSR + 传统模板引擎 + 合理的 Cache 机制，是一套足够 flexible 的企业级 Web 架构解决方案。后续，我将会进一步来完善这个设想方方面面的细节。
